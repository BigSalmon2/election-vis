<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Election: Wisconsin 2016</title>
<!--<script type="text/javascript" src="../d3/d3.v3.min.js"></script>-->
<script src="https://d3js.org/d3.v4.min.js"></script>
<style type="text/css">

	
.axis {
  font: 12px sans-serif;   
}

.axis path,
.axis line {
  fill: none;
  stroke: #aaa; 
  shape-rendering: crispEdges;
}

.axis text {
  fill: #858585;
}

.title {
  font: 500 100px serif; /*180px "Helvetica Neue"*/
  fill: #e5e5e5;
}

.party {
  font: 500 35px serif; /*180px "Helvetica Neue" "PT Sans"*/
  fill: #e5e5e5;
}

.incr {
  font: 500 35px serif;  /* sans-serif"Helvetica Neue"; 55px + - */
  fill: #e5e5e5; 
  cursor: pointer;
}

.incr:hover {
  fill: #ccc;
}

.circle {
/*	stroke: gray; */
/*	stroke-width: 0.5px;*/
	cursor: pointer;
}

.circle:hover {
	/*stroke: #555;*/
	fill-opacity: 0.8;
}

.vector {
  fill: none;
  stroke: steelblue;
  stroke-width: 1px;
  opacity: 0.4;
}

svg {
  margin-top: 2.5em;
  margin-bottom: 2.5em;
}

form {
  position: absolute;
  right: 50px;
  top: 50px;
  /*display:inline;*/
}

/*#search {
  border-radius: 0px;
  background-color: white;
  border: 1px solid #ddd;
}*/


.tooltip {
  /*border: 1px solid #999;*/
  /*line-height: 1;*/
  font: 16px serif;/*18px serif "Helvetica Neuesans-serif;  "PT Sans"*/
  /*font-weight: bold;*/
  /*padding: 5px;*/ 
  /*background: #fcfcfa;*/ /*rgba(0, 0, 0, 0.8) */ 
  color: #999;   /*#fff #888; #999*/
  /*border-radius: 2px;*/
  /*max-width: 1000px;*/
}

body {
  /*background: #f5f5f1;*/
  color: #888;  /*#aaa;*/
  font-family: "PT Serif", serif;
  /*1em auto 4em auto;*/  
/*margin: 50px 150px; 
  position: relative;
  width: 960px;*/
}

body > p, li > p {
  line-height: 1.5em;
}

body > p {
  width: 800px;
}


</style>
</head>

<body>


<div id="formholder">
<form name="myform" onSubmit="return handleClick()" >   <!--action="#"-->
        <input type="text" id="myVal" placeholder="County or State">
        <input id="search" name="Submit"  type="submit" value="Search" >
        <!-- <input type="reset" value="Reset" onclick="document.myform.submit;"> -->
        <!-- <input type="button" value="Reset" onclick="document.myform.reset(); document.myform.submit();"> -->
        <input type="button" value="Reset" onclick="document.myform.reset(); handleClick();">
</form>
</div> 


<script type="text/javascript">

//Todo:
// Add electoral college sum, change based on county drag
// 



var margin = {top: 20, right: 20, bottom: 50, left: 30},  
	// width = 1100 - margin.left - margin.right,
	// height = 600 - margin.top - margin.bottom;
	// width = 850 - margin.left - margin.right,
	// height = 450 - margin.top - margin.bottom;
	width = 0.95*window.innerWidth - margin.left - margin.right,   //window.innerWidth
	height = 0.9*window.innerHeight - margin.top - margin.bottom;



//Formatting Functions
var pctFormat = d3.format(".2%")
var thsdFormat = d3.format(",")

//Create SVG
var svg = d3.select("body").append("svg")
	.attr("width", width + margin.left + margin.right)
	.attr("height", height + margin.top + margin.bottom)
	//.attr("style", "outline: 1.5px solid #e5e5e5;")
	.append("g")
	.attr("transform", "translate(" + margin.left + "," + margin.top + ")");


//Year Title
var title = svg.append("text")
    .attr("class", "title")
    .attr("dy", height-10)  
    .attr("dx", ".35em");  

var demtext = svg.append("text")
    .attr("class", "party")
    .attr("dy", height-50)  
    .attr("dx", 243);  


var reptext = svg.append("text")
    .attr("class", "party")
    .attr("dy", height-14)  
    .attr("dx", 243);  


//Define static scales
var xScale = d3.scaleLinear()
	.domain([-100, 100])   //-100, 100
	.range([0, width]);

var yScale = d3.scaleLinear()
	.domain([0, 100])  //Max margin is 100
	.range([height, 0]);


//Base the color scale on the democratic margin.  
var colorScale = d3.scaleLinear()
	.domain([-80, 0, 80])
	//.domain([d3.min(...), 0, d3.max(data, function(d) {return d.; })])
	//.range(['#FF0000', '#FFFFFF', '#0000FF'])
	//.range(['#EF3B2C', '#FFFFFF', '#08519C'])
	//.range(['#EF3B2C', '#dadada', '#08519C'])
	//.range(['#EF3B2C', '#08519C'])
	.range(['#EF3B2C', '#885ead', '#08519C'])  //#9975b9  #885ead  #aa8cc5
	.interpolate(d3.interpolateRgb);  

//Define x, y axes
var xAxis = d3.axisBottom(xScale);
var yAxis = d3.axisLeft(yScale);

//Append Axes
svg.append("g")
	.attr("class", "axis")
	.attr("transform", "translate(0," + height + ")")
	.call(xAxis)
	.append("text")
	.attr("y", "3em")
	.attr("x", width/2)
	.text("Democratic Margin (%)");

svg.append("g")
	.attr("class", "axis")
	.call(yAxis)
	.attr("transform", "translate(" + (width/2) + ",0)")
	.append("text")
	.attr("transform", "rotate(-90)")
	.attr("y", 6)
	.attr("dy", "-3.75em")  
	.style("text-anchor", "end")
	.text("Turnout (%VAP)");


//Statically place tooltip:
//http://stackoverflow.com/questions/30051141
var tooltip = d3.select("body")
	.append("div")    
	.style("position", "absolute")
	.style("visibility", "hidden")
	// .style("left", width/2 + margin.left + 8 + "px")
	// .style("top", height - margin.bottom + 8 + "px")
	.style("left", width/2 + margin.left + 8 + "px")
	.style("top", height - margin.bottom/3 + "px")
	.attr("class", "tooltip");


function tooltipOn(d) {
	//Transition might prevent mouseout from registering
	// tooltip.transition()
	// 	.duration(500)
	// 	.style("visibility", "visible");
	//"Turnout: " + pctFormat((d.num_rep+d.num_dem)/(d.county_num/d.turnout))
	//d.county_num + "," + d.turnout + "," + d.vap
	tooltip.style("visibility", "visible")
		.html(
		d.county + "<br>" +
		"D: " + pctFormat(d.num_dem/d.county_num) +
		" R: " + pctFormat(d.num_rep/d.county_num) + "<br>" +
		"Turnout: " + pctFormat(d.turnout) + "<br>" +
		"Voters: " + thsdFormat(Math.round(d.county_num)) + "<br>" );
		//"VAP: " + thsdFormat(d.vap)); 
}


var currentSearch = "";
var searchTerms = "";

function handleClick(event){
	currentSearch = document.getElementById("myVal").value;
    //console.log(currentSearch);
    //draw(currentSearchTerm);
    //update(yearData, year);

    //var search="";
    var words = currentSearch.split(",").map(function(s) { return s.trim() });  

 	//Modifies global search variable, also used in update()
    searchTerms = RegExp(words.join('|'), "gi");

    //console.log(search);


    svg.selectAll("circle").attr("fill",function(d){

		if (d.county.search(searchTerms) != -1 ) {   //d.county.search(currentSearch)
			return colorScale(((d.num_dem-d.num_rep)/d.county_num)*100);
		}else {
			return "rgba(192,192,192,0.05)";  //'none'
		}
	}); //.on("mouseover", null)
	// .transition()
	// .duration(1000);

	return false; //Don't reload page
}


function parseRows(d) {
	return {'county': d.county, 'county_num': +d.county_num, 'turnout': +d.turnout*100,
		   'num_rep': +d.num_rep, 'num_dem': +d.num_dem, 'year': +d.year, 
		   'vap': +d.vap, 'dem_margin': ((d.num_dem-d.num_rep)/d.county_num)*100 };
}


d3.csv('./US_County_Level_Presidential_Results_08-16_nofilter.csv', parseRows, function(error, data) {

	if (error) {throw error};

	var dataset = d3.nest()
		.key(function(d) { return +d.year; })
		.entries(data);

	//console.log(dataset);

	//Data for loading all vectors initially
	// var vectorInitial = d3.nest()
	// 	.key(function(d) {return d.county})
	// 	.entries(data); //

	// console.log(vectorData);


	var years = [];
	for (var i=0; i<dataset.length; i++) {
		years.push(+dataset[i].key)
	}
	var year = years[0];

	//Create a copy, so it can be edited on drag:
	//var yearData = Object.assign({}, getYearData(dataset, year));
	var yearData = copyObj(getYearData(dataset, year));


	//Data is just array of all objects from csv
	var rScale = d3.scaleLinear()
		.domain([0, d3.max(data, function(d) {return d.county_num; })])
		.range([2, 60]);


	//Append increment buttons
	var incr = svg.append("text")
		.attr("class", "incr")
		.attr("dy", height-43) // 1em
		.attr("dx", 0)  //.5em
		.html("&#9650;")
		.on("click", function() {
			year += 4;
			if (year > years[years.length - 1]) {
				year = years[0]
			}
			//Assign to new object, update circles:
			yearData = copyObj(getYearData(dataset, year));

			//console.log(yearData);
			//yearData = yearData.slice(0,500);

			update(yearData, year);
		});

	var decr = svg.append("text")
		.attr("class", "incr")
		.attr("dy", height-10)
		.attr("dx", 0)  //".5em"
		.html("&#9660;")
		.on("click", function() {
			year -= 4;
			if (year < years[0]) {
				year = years[years.length - 1];
			} 
			//Assign to new object, update:
			yearData = copyObj(getYearData(dataset, year));
			update(yearData, year);
		});


	//Dragging behavior
	//https://bl.ocks.org/mbostock/6123708
	var drag = d3.drag()
	    .on("drag", dragged)
	    .on("end", ended);


	function dragged(d) {
		//Remove transitions temporarily
		d3.selectAll("circle").transition();

		//Issue when dragged across 0 threshold, county_num = 0
		if (d3.event.y >= height) {
			return;
		}

		//Relocate circle with mouse
		d3.select(this).attr("cx", d.x = d3.event.x).attr("cy", d.y = d3.event.y);
		
		//Avoid case of no shift
		if (d.x === undefined || d.y === undefined) {
			return;
		}


		var newMargin = xScale.invert(d.x)/100,
			newTurnout = yScale.invert(d.y)/100,  //Math.abs()  d.y
			oldMargin = (d.num_dem-d.num_rep)/d.county_num,
			marginChange = newMargin-oldMargin, 
			dfrac = d.num_dem/d.county_num,
			rfrac = d.num_rep/d.county_num;

		//Recalculate fractions based on margin change
		//Half goes to each side, zero sum
		dfrac += marginChange/2;   
		rfrac -= marginChange/2;

		//Add increses in turnout to county_num
		//Assume change in turnout affects D&R equally
		//d.county_num = newTurnout*vap;
		d.county_num = newTurnout*d.vap;


		// Recalculate based on margin change first, assumes
		// margin changes are zero sum between parties.
		d.num_dem = dfrac*d.county_num;
		d.num_rep = rfrac*d.county_num;
		d.turnout =  newTurnout;

		//Call the tooltip function each time to update.  
		tooltipOn(d);
		//Update score as well:
		updateScore(yearData);
		//Wait to update circles until ended below
		//update(yearData, d.year);
	}

	function ended(d) {
		//Update circle radius, color at end of drag.  
		update(yearData, d.year);

	}

	function updateScore(yearData) {

		//Could get this data directly from dataframe,
		//but want to calculate so can be updated easily on drag.   
		var sums = [0,0,0];
		for (var i=0; i<yearData.length; i++) {
			sums[0] += yearData[i].num_dem;
			sums[1] += yearData[i].num_rep;
			sums[2] += yearData[i].county_num;
		}

		var dfrac = sums[0]/sums[2],
			rfrac = sums[1]/sums[2];

		//update dfrac rfrac text, update color background
		demtext.text('D ' + pctFormat(dfrac))  
		reptext.text('R ' + pctFormat(rfrac)) 


		//demtext.style('color', 'red')
		if (dfrac > rfrac) {
			demtext.style('fill', '#bbb');
			reptext.style('fill', null);
		} else {
			demtext.style('fill', null);
			reptext.style('fill', '#bbb');
		}

		//Optional, set background color based on winner
		// var backColor = dfrac > rfrac ? colorScale(5) : colorScale(-5);
		// //var backColor = colorScale((dfrac-rfrac)*100);
		// d3.selectAll('svg')
		// 	.style('background-color', backColor);
	}


	function update(yearData, year) {

		//Change D,R scores:
		//updateScore(yearData);

		//Update title
		title.text(year);

		//Create any new circles
		// var circles = svg.selectAll("circle")
		// 	.data(yearData)
		// 	.enter().append("circle")
		// 	.attr("class", "circle")
		// 	.attr("cx", function(d) {
		// 		return xScale(((d.num_dem-d.num_rep)/d.county_num)*100);
		// 	})
		// 	.attr("cy", function(d) {
		// 		return yScale(d.turnout*100);
		// 	})
		// 	.attr("r", function(d) {
		// 		return rScale(d.county_num);
		// 	})
		// 	.attr("fill",function(d){
		// 		return colorScale(((d.num_dem-d.num_rep)/d.county_num)*100);
		// 	})
		// 	.call(drag)
		// 	.on("mouseover", tooltipOn)
		// 	.on("mouseout", function(d){return tooltip.style("visibility", "hidden");});

		//var node = d3.select(this); console.log(node); node.attr("prevData", [this.cx, this.cy])


		// var circles = svg.selectAll("circle")
		// 	//.each(function() {console.log(this.cx);})
		// 	.data(yearData, function(d) { return d.county; });  //includes key function for object constancy: https://bost.ocks.org/mike/constancy/
		// 	// .call(drag)
		// 	// .on("mouseover", tooltipOn)
		// 	// .on("mouseout", function(d){return tooltip.style("visibility", "hidden");});

		// circles.exit().remove();

		// //console.log(circles);

		// circles.enter().append("circle")
		// 	.attr("class", "circle")
		// 	.merge(circles)
		// 	.transition()
		// 	.duration(1000) //750;
		// 	//.ease(d3.easeLinear)
		// 	//.tween("lineDraw", drawVector)
		// 	.attr("cx", function(d) {
		// 		return xScale(((d.num_dem-d.num_rep)/d.county_num)*100);
		// 	})
		// 	.attr("cy", function(d) {
		// 		return yScale(d.turnout*100);
		// 	})
		// 	.attr("r", function(d) {
		// 		return rScale(d.county_num);
		// 	})
		// 	.attr("fill",function(d){

		// 		if (d.county.search(searchTerms) != -1 ) {   //d.county.search(currentSearch) != -1
		// 			return colorScale(((d.num_dem-d.num_rep)/d.county_num)*100);
		// 		}else {
		// 			return "rgba(192,192,192,0.05)";  //'none'
		// 		}
		// 	});
			// .call(drag)
			// .on("mouseover", tooltipOn)
			// .on("mouseout", function(d){return tooltip.style("visibility", "hidden");});


		// var otherLineFunction = d3.line()
		// 	.x(function(d) { return d[0]; })
		// 	.y(function(d) { return d[1]; });

		// circles.append("path")
		// 	.attr("class", "line")
  //     		.attr("d", "M-5,0 L-15,15 L15,0 L-15,-15 Z"); //function(d) { return otherLineFunction(d.values); });

		// circles.transition().duration(1500) //750;
			
		// circles.on("mouseover", tooltipOn)
		// 	.on("mouseout", function(d){return tooltip.style("visibility", "hidden");});

		// function drawVector(d){
		//   //var node = d3.select(this);

		//   //console.log(node);

		//   // var firstX = node.attr('cx');
		//   // var firstY = node.attr('cy');
		//   //var firstX = +node._groups[0].circle.cx.baseVal.value;
		//   //var firstY = +node._groups[0].circle.cy.baseVal.value;

		//   var lastX = xScale(((d.num_dem-d.num_rep)/d.county_num)*100);
		//   var lastY = yScale(d.turnout*100);

		//   var lineData = [[0, 0], [lastX, lastY]];

		//   //console.log(lineData);
		   
		//   // This function returned by tracker is what will execute at each 'tick'
		//   // in the transition animation
		//   return function(t){
		//     //var curX = Math.floor(circle.attr('cx'));
		//     //var curY = Math.floor(circle.attr('cy'));
		//     // only update if circle has moved at least a pixel in x and y
		//     // directions
		//     // if(curX !== lastX && curY !== lastY){
		//     //   d3.select('.position-track').text("X: " + curX + ", Y: " + curY);
		//     // }

		//     //console.log(lineData)

		//     if (t === 1) {
		//     	//d3.select
		//     	//console.log("entered");
		//     	//console.log(otherLineFunction(lineData));

		// 		svg.append("path")
		// 			.attr("class", "line")
		// 			.attr("d", function() {  return otherLineFunction(lineData); });

		//     }
		//   }
		// }


		//Update circles
		// svg.selectAll("circle").data(yearData)
		// 	.transition()
		// 	.duration(750)
		// 	.attr("class", "circle")
		// 	.attr("cx", function(d) {
		// 		return xScale(((d.num_dem-d.num_rep)/d.county_num)*100);
		// 	})
		// 	.attr("cy", function(d) {
		// 		return yScale(d.turnout*100);
		// 	})
		// 	.attr("r", function(d) {
		// 		return rScale(d.county_num);
		// 	})
		// 	.attr("fill",function(d){
		// 		return colorScale(((d.num_dem-d.num_rep)/d.county_num)*100);
		// 	});

		//var prevYear = years[years.indexOf(year) - 1];

		//console.log(prevData);

		//So the animations, work, but the issue is the size of the dataset.  
		//prevData = prevData.slice(0,500);

		//console.log(prevData);

		//console.log(years[years.indexOf[year] - 1])
		// console.log(year, years)
		// console.log(years.indexOf[year]);
		// console.log(years.indexOf[year] - 1);



		// console.log("prev",prevData);
		// console.log("year", yearData);
		// console.log("comb",combineData);

		// console.log("vect", vectorData);


		//Initialize vector paths with same x1, x1, y1, y2
		// var vectors = svg.selectAll(".vector")
		// 	.data(vectorData)   //, function(d) { return d.key; }
		// 	.append("path")
		// 	.attr("class", "line")
		// 	.attr("d", function(d) { return easyLineFunction(d.values); });
  //     		//.style("stroke", function(d) { return z(d.id); });

  		//d3.selectAll("vector").remove()

		//Applies to each element in the values array
		var easyLineFunction = d3.line()
			.x(function(d) { return xScale(d.dem_margin); })
			.y(function(d) { return yScale(d.turnout); });


		var prevYear = year - 4;
		if (prevYear < years[0]) {
			prevYear = years[years.length - 1];
		} 

		//console.log(prevYear);


		var prevData = getYearData(dataset, prevYear);


		var combineData = yearData.concat(prevData);


		var vectorData = d3.nest()
			.key(function(d) {return d.county})
			.sortValues(function(a,b) { return a.year - b.year; } )
			.entries(combineData); //

  		var vectors = svg.selectAll(".vector")
  			.data(vectorData, function(d) { return d.key; });

  		//console.log("Exiting", vectors.exit());

  		vectors.exit().remove()

  		//console.log("Entering", vectors.enter());

  		vectors.enter()
			.append("path")
			// .attrTween('d', getSmoothInterpolation)
			.attr("class", "vector")
			.attr("d", function(d) { return easyLineFunction(d.values); })
			.attr("stroke-dasharray", function() {
			    var totalLength = this.getTotalLength();
			    return totalLength + " " + totalLength;
			})
			.attr("stroke-dashoffset", function() {
			    var totalLength = this.getTotalLength();
			    return totalLength;
			})
			.transition()
			.duration(1000)
			//.ease("linear")
			.attr("stroke-dashoffset", 0);


		//Ok, so it's not the data processing taking the time, it's the rendering of 3000k+ lines
		//Below just renders all vectors at once
  	// 	var vectorInitials = svg.selectAll(".vector")
  	// 		.data(vectorInitial, function(d) { return d.key; })
  	// 		.enter()
			// .append("path")
			// // .attrTween('d', getSmoothInterpolation)
			// .attr("class", "vector")
			// .attr("d", function(d) { return easyLineFunction(d.values); })
			// .attr("stroke-dasharray", function() {
			//     var totalLength = this.getTotalLength();
			//     return totalLength + " " + totalLength;
			// })
			// .attr("stroke-dashoffset", function() {
			//     var totalLength = this.getTotalLength();
			//     return totalLength;
			// })
			// .transition()
			// .duration(1000)
			// //.ease("linear")
			// .attr("stroke-dashoffset", 0);

			
			// .transition()
			// .duration(1000);

			// .attr("stroke-dasharray", function() { return d3.select(this).node().getTotalLength() + " " + d3.select(this).node().getTotalLength() } )
			// .attr("stroke-dashoffset", d3.select(this).node().getTotalLength())
			// .transition()
			// .duration(2000)
			// .ease("linear")
			// .attr("stroke-dashoffset", 0);


  	// 	var vectors = svg.selectAll(".vector")
			// .data(vectorData, function(d) { return d.key; })   //, function(d) { return d.key; }
			// .enter()
			// .append("path")
   //    		.attr("class", "vector")
   //    		.attr("d", function(d) { return easyLineFunction(d.values); });



	
	}

	// function getSmoothInterpolation(data) {
	//   return function (d, i, a) {
	//       var interpolate = d3.scaleLinear()
	//           .domain([0,1])
	//           .range([1, data.length + 1]);

	//       return function(t) {
	//           var flooredX = Math.floor(interpolate(t));
	//           var weight = interpolate(t) - flooredX;
	//           var interpolatedLine = data.slice(0, flooredX);
	              
	//           if(flooredX > 0 && flooredX < 31) {
	//               var weightedLineAverage = data[flooredX].y * weight + data[flooredX-1].y * (1-weight);
	//               interpolatedLine.push({"x":interpolate(t)-1, "y":weightedLineAverage});
	//               }
	      
	//           return easyLineFunction(interpolatedLine);
	//           }
	//       }
	// }





	// var lineFunction = d3.line()
	// 	.x(function(d) { return xScale(((d.num_dem-d.num_rep)/d.county_num)*100); })
	// 	.y(function(d) { return yScale(d.turnout*100); });
		//.interpolate("linear");


	function initialize(yearData, year) {

		//Change D,R scores:
		//updateScore(yearData);

		//Update title
		title.text(year);

		//Create any new circles
		// var circles = svg.selectAll("circle")
		// 	.data(yearData, function(d) { return d.county; })
		// 	.enter().append("circle")
		// 	.attr("class", "circle")
		// 	.attr("cx", function(d) {
		// 		return xScale(((d.num_dem-d.num_rep)/d.county_num)*100);
		// 	})
		// 	.attr("cy", function(d) {
		// 		return yScale(d.turnout*100);
		// 	})
		// 	.attr("r", function(d) {
		// 		return rScale(d.county_num);
		// 	})
		// 	.attr("fill",function(d){
		// 		return colorScale(((d.num_dem-d.num_rep)/d.county_num)*100);
		// 	})
		// 	.call(drag)
		// 	.on("mouseover", tooltipOn)
		// 	.on("mouseout", function(d){return tooltip.style("visibility", "hidden");});

		//console.log(vectorData);

		// var vectors = svg.selectAll(".vector")
		// 	.data(vectorData, function(d) { return d.key; })   //, function(d) { return d.key; }
		// 	.enter()
		// 	.append("path")
  //     		.attr("class", "line")
  //     		.attr("d", function(d) { return lineFunction(d.values); });
  //     		//.style("stroke", function(d) { return z(d.id); });

	}		


	//Initialize scatterplot
	//update(yearData, year);
	initialize(yearData, year);



	// Helper functions: 
	function copyObj(original) {
		return JSON.parse(JSON.stringify(original));
	}

	function getYearData(dataset, year) {
		for (var i=0; i<dataset.length; i++) {
			if (Number(dataset[i].key) === year) {
				return dataset[i].values;
			}
		}
	}




});
</script>
</body>
</html>